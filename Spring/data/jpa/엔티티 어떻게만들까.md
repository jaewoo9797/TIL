# `Entity` 어떻게 만들까?

가장 먼저 `application.yml` 을 기본적인 설정한다.
```yaml
spring:
  h2:
    console:
      enabled: true
      path: /h2
  datasource:
    url: jdbc:h2:mem:test
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: create
    generate-ddl: true
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```
콘솔로 들어가서 데이터베이스에 엔티티가 잘 생성되었는지, JPA의 기본적인 설정을 해주었다. sql도 어떻게 생성되는지
확인하는 설정도 포함되어 있다.

## 연관관계 매핑하기
엔티티를 먼저 설계한다. 
1. `post` 엔티티
2. `comment` 엔티티
3. `User` 엔티티

`User (1) ----< (N)  Post -----< (N) comment`

### 연관관계의 주인은 누구?
연관관계 매핑의 주인이란 무엇인가?   
연관관계 주인이 필요한 이유 : 객체 지향의 패러다임과 데이터베이스의 패러다임에 차이가 있기 때문이다.

> 양방향과 단방향 매핑   
> `양방향` : 두 객체 모두가 각각 참조용 필드를 갖고 참조한다.   
> `단방향` : 두 객체 사이에 하나의 객체만 참조용 필드를 가지고 참조한다.

연관관계의 주인(mappedBy)

연관관계의 주인을 지정한다는 것은, 객체의 두 관계 중 제어의 권한 (데이터 조회, 저장, 수정, 삭제)를
갖는 실질적인 관계가 무엇인지 JPA에 알리는 것

따라서 연관관계의 주인은 연관관계를 갖는 두 객체 사이에서 조회, 저장, 수정, 삭제를 할 수 있지만,
주인이 아니면 조회만 가능하다.

누구를 주인으로 지정해줘야 하는가? 간단하게 주인은 외래키가 있는 곳을 주인으로 지정하면 된다.
ERD에서 1대 N 관계를 설계할 때, N측 엔티티가 1측 엔티티의 ID를 참조하는 방식으로 관계를 맺는다.   

## `BaseEntity`
엔티티에는 공통되는 속성이 존재한다. 


`createAt`, `updateAt`
이를 공통적으로 관리하는 `baseEntity`를 만들어서 관리해보고 싶다.

## `@MappedSuperclass`란
객체 상속을 통해 사용하지만, 상속관계 매핑의 목적보다 공통 매핑 정보가 필요할 때 사용한다.
중복되는 속성을 생성하여 Entity생성 시 상속받아 중복되는 속성을 처리하는 데에 의미를 둔다.

```java
import javax.annotation.processing.Generated;

@Getter
@MappedSuperclass
public class BaseEntity {
    
    @CreationTimestamp
    @Column(name="created_at", nullable=false, updateable = false)
    private LocalDateTime createAt;
    
    @UpdateTimestamp
    @Column(name="updated_at", nullable = false)
    private LocalDateTime updateAt;
}
```

`@Column`의 속성 `nullable`은 기본적으로 true의 값을 가진다. 이는 기본적으로 null이 들어올 수 있다
해당 필드는 DDL 생성 시 null 이 들어갈 수 있다. 만약 nullable 한 값을 넣지 않으려면 즉, not null로 설정하고 싶으면
속성 값을 `false`로 주어주자.

### Auditing
감사, 심사의 의미를 가진다. 이는 엔티티가 수정 생성 되는 시점을 감지하여 그 시간과 생성, 수정 한 사람을
기록하여 이력을 남길 수 있습니다.

`@EnableJpaAuditing` 어노테이션을 사용하여 기능 활성화
두 가지 방법이 존재
- Application 클래스 단계에서 어노테이션을 추가
```java
@EnableJpaAuditing
@SpringBootApplication
public class XXXApplication {
    
    public static void main...
}
```

- Configuration 분리
```java
@EnableJpaAuditing
@Configuration
public class AuditingConfig {
    
}
```
test code
```java
@DataJpaTest
@Import(AuditingConfig.class)
class TodoRepositoryTest {
    
}
```

### BaseEntity에 추가
조금 다르지만, 차이점은 다음과 같다. Jpa에서 제공하는 기능인가? Hibernate에서 제공하는 기능인가

지금 보는 baseEntity에 추가하는 기능은 Jpa에서 제공하는 기능으로 하이버네이트와 다르게 추가로 더 많은 기능 (생성, 수정 사용자 기록 등)을 제공하고
Spring 생태계와 잘 통합되어 많이 활용된다.

```java
@Getter
@MappedSuperClass
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {
    
    // ...
    
    // 기존 어노테이션 @CreateionTimestamp
    @CreatedDate // 변경된 어노테이션
    @Column(name =...)
    
    // 기존 어노테이션 @UpdateTimestamp
    @LastModifedDate // 변경된 어노테이션
}
```

Jpa에서 제공하는 수정한 사람, 생성한 사람을 등록하고 싶을때

```java
@CreateBy
@Column(updateable = false)
private String createdBy;

@LastModifedBy
private String lastModifiedBy;
```
## 기본 생성자 어노테이션
### `@NoArgsConstructor`

기본 생성자를 생성해주는 어노테이션이다. 자바에서 생성자를 선언할 때 상속받는 객체가 있다면, 외부에서는 해당 생성자 호출을
하지 못하도록 하지만, 자식 객체에서는 객체 생성을 할 때 기본적으로 부모객체도 생성을 해주어야 한다. super 예약어를 통해
자식 객체가 생성되기전에 부모객체를 생성한다.

궁금했던 기본 생성자 어노테이션에 속성으로 기본생성자의 접근 제어자를 지정해주는 속성이였다.

여기서 하나 더 알 수 있는점은 객체를 DB에서 조회해서 가지고 올 때 `LAZY` 방식이냐, `EAGER` 방식이냐에 따라서 프록시 객체
(상속받은 자식객체)로 가지고 올지 결정을 하게된다. `LAZY` 방식으로 조회를 해올때는 프록시 객체를 이용하기 때문에 꼭
기본 생성자의 접근제어자를 `public` 또는 `protected`로 설정을 해주어야 한다.

## 유저의 정보를 어떻게 엔티티에 설계해야할까?
유저의 정보를 저장하고 있는 user객체 엔티티

엔티티 내부에 객체로 정보를 저장하고 있는 UserInfo라던지, 이메일, 핸드폰번호 등은 객체로 관리하는게 좋을까?

객체지향프로그래밍하는데 고민이된다.

간단한 프로젝트일 경우 빠르게 프로토 타입으로 String 필드로 작성한다.

Email이나, PhoneNumber는 객체로 만들어서 관리해도 괜찮을 것 같다.

일단 EMial은 특정 도메인에 따라서 다르게 처리할 경우에 유용하게 사용할 수 있을 것 같다.

`Email` 객체를 생성
- 정규식을 이용하여 생성 검사
- 마스킹
- 도메인 정보 호출
```java
@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Email {
    private static final String PATTERN = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    private static final Pattern EMAIL_PATTERN = Pattern.compile(PATTERN);
    private String email;

    private Email(String email) {
        this.email = email;
    }

    public static Email of(String email) {
        isValidOrThrow(email);
        return new Email(email);
    }

    private static void isValidOrThrow(String email) {
        Objects.requireNonNull(email, "email must not be null");
        if (!isValidEmail(email)) {
            String format = String.format("Invalid email address: %s", email);
            throw new IllegalArgumentException(format);
        }
    }

    private static boolean isValidEmail(String email) {
        return EMAIL_PATTERN.matcher(email).matches();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Email email1 = (Email) o;
        return Objects.equals(email, email1.email);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(email);
    }

    @Override
    public String toString() {
        return email;
    }
}
```

이런식으로 Email을 검증하고 생성하는 로직을 캡슐화했다.

이제 제대로 작동하는지, 테스트해보고 싶은 욕구가 쏟는다. 그리고 생성할 때 팩토리메서드를 어노테이션으로 만들 수 있는 것으로 알고있음

## `Entity` 테스트는 어떻게 하나??
