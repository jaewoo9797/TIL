# 서비스와 레포지터리에 관한 고민

우선 해당 글에서는 넓은 범위의 고민이 함께 존재합니다. 각 고민들은 서로 연관되어 있는 부분이 존재하고 
영향을 미치는 부분이 존재합니다. 이에 러프하게 제목을 잡고 하나하나 정복해보고자 합니다.

- `DTO` 어느 레이어에서 변환하여 반환해야할까?
- 서비스 레이어 메서드에서 `DTO`를 리턴하는 것에대한 고찰
- 서비스 레이어에서 다른 서비스 레이어를 의존하는 것, 서비스 레이어에서 레포지터리 레이어만 의존하는 것에 대하여

<br/>

## `DTO` , `Domain` 그리고 서비스 레이어 레포지터리 레이어
이 문서의 시작은 `DTO`과 `Domain` 의 변환을 담당하는 것이 적절한가에 대한 고민에서부터 시작했습니다.
저는 변환을 담당하는 `Converter` 객체를 만들어서 책임을 분리하여 코딩을 진행했는데, 
다른 방법에 대해서도 알게 되어 고민을 하게 되었습니다.

<br/>

제가 `converter`로 변환 했던 방법과 다른 방법으로는 `DTO` 클래스 파일 안에서 변환을 해주는 메서드를 만들어서 변환해주는 방법이 있습니다. 예를 들어
클라이언트의 요청을 도메인 객체로 변환하는 것을 코드로 살펴보겠습니다.

```java
public record ChannelCreateRequest (String name, String description) {
    
    public Channel toChannel() {
        return new Channel (this.name, this.description);
    }
}
```

<br/>

위와 같은 변환 메서드를 `DTO` 안에 배치하였습니다. 변환이 필요한 레이어에서 메서드를 호출하여 사용할 수 있는 장점이 있습니다.
제가 생각하기에 이 방식의 단점은 `DTO`가 `Domain`에 의존하게 되며 강하게 결합되어 도메인의 변경에 따라 영향을 직접적으로
받게 됩니다. 그리고 채널 객체를 생성하는 비즈니스 로직이 복잡해질 경우에는 안에서 처리하는 것이 복잡해질 수 있습니다.

예를 들어, 하나의 채널을 생성하는데 유저의 정보와 채널별로 카테고리가 존재하여 카테고리의 정보도 포함되어야 한다고
가정해보겠습니다.

```java
public class Channel {
    
    //...
    private User manager;
    private Category category;
}
```

<br/>

*채널 객체*를 생성하기 전에 해당 *유저 객체*와 *카테고리 객체*를 조회해와서 저희가 저장하려는 채널 객체를 
생성해야합니다. 데이터 정합성을 위해서 request로 받은 유저와 카테고리 정보를 이용해서 
데이터베이스에서 조회해 객체를 생성해야 한다고 생각하기에 `DTO` 내부에서 변환하는 것에는 적합하지 않다고 생각합니다. 
만약 `DTO` 내부에서 `repository`를 의존해서 내부에서 처리한다고 하면 데이터 전송을 위한 DTO 객체의 책임이 과해지고 
의존해야하는 방향이 적합하지 않다고 생각합니다. 

또한 클라이언트의 요청을 받아 request 객체로 매핑하는 컨트롤러 또한 적합하지 않다고 생각합니다. 컨트롤러는 클라이언트와 서버
사이에서 요청과 응답을 수행하는 역할이라고 생각하기 때문입니다. 이에 컨트롤러는 서비스 레이어에 위임하여 비즈니스 로직을
수행해야 합니다.

<br/>

```java
public record ChannelCreateRequest(Long userId, Long categoryId, String name, String description) {
}

@Service
public class ChannelService {
    
    //.. 레포지터리, 생성자 등등..
    
    public Channel createChannel(ChannelCreateRequest request) {
        User user = userRepository.findById(request.userId());
        Category category = categoryRepository.findById(request.categoryId());
        Channel channel = new Channel(request.name(), request.description(), user, category);
        channelRepository.save(channel);
    }
}
```

<br/>

### `DTO` ➡️ `Domain` 
제가 생각하는 `DTO` -> `Domain` 으로의 변환은 `서비스 레이어에서 담당해야 한다` 입니다. 간단한 객체 생성을 하는 클라이언트의 요청에는 `DTO` 내부에 필요한
모든 데이터를 받아서 객체를 생성할 수도 있다고 생각합니다.

저는 두 가지의 이유로 간단한 객체의 생성일지라도 `DTO` 내부에서 변환을 하는 것을 반대합니다.
1. `DTO` 객체가 도메인 객체를 의존하여 결합을 발생시킬 이유가 있는가?
2. 어느 `DTO` 는 내부적으로 변환을 하고, 일부 `DTO`는 서비스 레이어에서 변환을 하는 일관성이 없는 코딩

**첫 번째**로 두 객체 사이에 발생하는 결합을 생각하면 도메인의 변경에 영향을 강하게 받는 `DTO`를 만들게 되고, 데이터를 전달
하는 역할인 `DTO`가 도메인을 알게되며 도메인을 의존하는 새로운 관계가 생긴다. `service` -> `domain` <- `DTO`

**두 번째**로는 일관성이 없어진다. 프로그래밍을 하는 것은 혼자만이 하는 것이 아닌, 옆의 동료와 함께 만들어가는 과정이다.
일관성이 없다면 협업간에 무분별한 코드가 생성되고 혼란을 불러오며, 불필요한 리소스를 소비하게 된다고 생각한다. 이에
모두 같은 방식으로 적절한 선택을 통해 일관성 있는 작업을 해야한다고 생각한다. 물론 `DTO` 내부에서 변환하는 것이 더 
적합하다고 동료간의 타협이 이루어지면 유연하게 작업해야하는 부분이기도 하다.

<br/>


### `Domain` ➡️ `DTO`
앞서 `DTO`에서 `Domain` 으로 변환하는 과정에 대한 생각을 정리하였습니다. 이번에는 반대로 가공된 데이터를 클라이언트에게
반환해주는 방법에 대해서 생각해보겠습니다.

이번에는 여러 방면을 고려하여 결정을 해야한다고 생각했습니다. 먼저 `DTO`가 도메인 객체를 파라미터로 받아 변환하는 방식을 
코드로 살펴보겠습니다.

<br/>

```java
public record ChannelResponse (
        Long channelId,
        String channelName,
        String channelDescription,
        String managerName,
        Long currentUserCount,
        Long maxUserCount
) {
    
    public static ChannelResponse toDto(Channel channel) {
        return new ChannelResponse(...);
    }
}
```

<br/>

먼저 해당 변환 메서드를 정적 메서드로 만든 이유는 java 의 record 객체는 생성자를 커스텀할 수 없기에 정적 메서드를 이용해서
해당 `DTO` 를 반환하도록 메서드를 작성하였습니다. 

저는 `DTO` -> `Domain` 변환에서 설명했듯이 dto 내부에서 변환하는 메서드를 두는 것에 적절하지 않다고 생각합니다. 그렇기에
`DTO` 내부에 정적 메서드를 이용해서 변환을 하기보다는 서비스 레이어나 반환하는 계층에서 `new ChannelResponse(...)` 생성자
를 통해서 반환해야 한다고 생각합니다. 

또한, 여기서 생각해볼 점이 몇가지 생기게 됩니다. 서비스 레이어에서 `DTO`를 반환하였을 경우 코드의 재사용성이 떨어집니다.
예를 들어 유저 도메인의 서비스에서 id로 유저 객체를 찾는 메서드는 dto를 반환하고 있으므로 채널 도메인 서비스에서는 이를
재사용할 수 없습니다. 반대로 서비스에서 domain을 반환하다고 해도 문제점은 존재합니다. 유저 객체를 찾는 메서드는 트랜잭션이 
readOnly 로 영속성 컨텍스트에 저장되지 않는 상태입니다. 즉, 변경이 일어났을 경우에 자동으로 더티체킹을 하지 못합니다. 

그렇다면 이 문제를 어떻게 해결할 수 있을까요? 일단 저는 서비스 레이어에서 필요한 도메인의 레포지터리만을 의존하도록
하는 방법이 생각났습니다. 현재 저희 스프린트 미션 베이스 코드도 살펴보면 모든 서비스 레이어에서 레포지터리만을 의존
하는 것을 확인할 수 있습니다. 

서비스 레이어에서 레포지터리만을 의존하게 된다면 문제점이 존재합니다. 중복코드가 발생한다는 것입니다. 중복코드가 발생하면
해당 로직이 변경되었을 때 파편화된 모든 로직을 찾아 하나하나 수정을 진행해주어야 합니다. 매우 큰 단점이라고 할 수 있습니다.
반대로 장점 또한 존재합니다. 초기에 빠르게 프로젝트를 진행할 수 있습니다. 각 서비스는 다른 서비스와 분리되어 해당 로직만
빠르게 구현할 수 있으며 반환 타입으로 dto 일 경우를 신경쓰지 않아도 됩니다, 레포지터리만을 의존하므로 순환참조의 문제를 걱정하지 않아도 됩니다.

## 결론
제 생각을 열심히 말하였지만, 결론은 정답이 없습니다. `DTO`를 사용해야하는 목적에 대해서 벗어나는 이야기이기 때문입니다. 컨트롤러에서 또는 서비스에서
변환을 하든 이건 레이어 관점에서 `DTO`를 생각한 것 입니다. 어느 위치에서 변환을 하든 `DTO`의 목적을 생각해보고, 그 이후에 유지보수를 생각해보면서
각자 상황에 맞게 트레이드 오프를 고려하여 적절한 선택을 해야한다는 것입니다. 

> 여러가지 방법이 있지만 실용적인 개발 아키텍처는 컨트롤러, 서비스, 리포지토리 계층이 모두 엔티티 계층에 의존하는 것입니다. 
> 왜냐하면 엔티티라는 것이 우리의 핵심 비즈니스이기 때문에 대부분의 로직은 엔티티가 필요합니다.
> 
> 물론 여기에서 기술적 문제든, 아키텍처 관점이든 필요에 따라서 엔티티를 어느 계층까지 노출해야 하는가는 또 다른 고민이 필요합니다.

[dto-인프런 질문](https://www.inflearn.com/community/questions/139564/dto-%EC%82%AC%EC%9A%A9%EC%8B%9C%EA%B8%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A7%88%EB%AC%B8?srsltid=AfmBOoqhqpN8qiPl1DsWGb7wrWZGArCk7wcJSP9fi1qiZUptHFglLqlR)

**정말 중요한 것은 의존관계라는 관점이 중요합니다.**   
지금까지 dto 관련해서 혼자 생각해본 글이였지만, 가장 중요한 부분은 **의존관계**라는 점인것 같습니다. dto를 사용하는 
목적을 다시 한 번 생각해보고, 팀원간의 적절한 소통으로 결정했으면 좋겠습니다! 추가로 정리하면서 저는 서비스 레이어에서 도메인
객체를 리턴하고 서비스 레이어를 재사용하도록 하는 방법이 개발하는데는 간편하고 좋을 것 같습니다 😅

(토론 좋아요! 의견 좋아요! 같이 이야기해봐요~)
