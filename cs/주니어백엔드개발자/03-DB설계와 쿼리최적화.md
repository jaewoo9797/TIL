# 3장 성능을 좌우하는 DB 설계와 쿼리

### Summary

- [성능과 DB](#성능에-핵심인-db)
- 인덱스 설계
- 조회 성능 개선 방법
- 주의 사항

## 성능에 핵심인 DB

DB 장비의 **CPU 사용률이 높아지고 쿼리 실행 시간이 느려지는 이유 중 하나로 테이블 풀 스캔**이 있습니다.

데이터가 적을 때는 문제가 되지 않았지만 데이터 개수가 증가하며 풀 스캔으로 인해 쿼리 실행 시간이 느려지기 시작합니다.

> [!NOTE]
>
> ### Full Scan
>
> 풀스캔은 테이블의 모든 데이터를 순차적으로 읽는 것을 말한다. **보통 쿼리의 where 절에 있는 조건에 대응하는 인덱스가 없을 때 풀 스캔이 발생한다.**

인덱스를 사용하는 것보다 전체 데이터를 탐색하는 것이 더 빠를떄도 풀 스캔이 발생한다. 데이터 개수가 적을 때에는 풀 스캔을 해도 성능 문제가 겉으로 드러나지 않지만 데이터 개수가 늘어나면 어느 순간 응답 시간이 기하급수적으로 증가하게 된다.

**테이블 풀 스캔이 CPU 사용량과 실행 시간을 증가시키는 이유**
CPU가 디스크의 모든 데이터를 읽고 처리해야 하기 때문입니다. 이 과정은 I/O 작업과 데이터 처리 로직을 모두 CPU가 담당하기 떄문입니다.

데이터베이스 서버 역시 하나의 컴퓨터입니다. 디스크에 데이터를 쓰고 읽는 I/O 작업을 수행합니다. 디스크에 저장한 데이터를 읽기 위해서 I/O 버스를 통해 전달합니다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fxi6BH%2FbtsN7C3Wyet%2FAAAAAAAAAAAAAAAAAAAAAOrWgyFIbIPWKCzm0o7ztqfJXv7S3H-U6-bdZeMp6QSP%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Da7AuZq2SBda8o7pOZLkbOdK3UAA%253D" alt="컴퓨터 구조" width="1000" height="auto" />

디스크는 `디스크 접근 시간`과 `시크 타임`이라는 개념이 존재합니다. 디스크 접근 시간은 데이터를 요청하고 전송 준비가 완료될 때까지의 시간을 의미합니다. 시크 타임은 디스크 암이 데이터를 읽기 위해 섹터를 찾는데 걸리는 시간입니다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fbwac3S%2FbtsN5mVP9k9%2FAAAAAAAAAAAAAAAAAAAAAPegAash8y8Q6MCSnfuY6XTrLIk4LuzJXEOrGqjx2NQr%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DjkMDSdzFLupB5dodkx4lbTORfDA%253D" alt="디스크 구조" width="600" height="auto" />

데이터를 찾기 위해서 디스크를 탐색하기 위한 방법으로 랜덤 I/O와 순차 I/O가 있습니다. 이는 데이터를 읽거나 쓰기 방식을 나타냅니다. 연속적인 순서로 접근하는 방식과 임의의 순서로 접근하는 방식입니다.

테이블 풀 스캔은 디스크에 쓰여진 데이터를 튜플 단위로 모두 읽습니다. 디스크에 쓰여진 데이터를 읽고 읽은 데이터를 I/O 버스를 통해서 CPU에게 전달해야 합니다. 이 I/O 작업과 데이터 처리 로직을 모두 CPU가 담당하게 되기 때문에 CPU 사용률이 올라가고 모든 튜플을 검사하기 때문에 응답 시간이 느려집니다.

결국 데이터베이스의 성능의 핵심은 디스크 I/O 접근을 최소화하는 것입니다. 그 방법으로 인덱스를 사용할 수 있습니다.

[테이블 풀 스캔으로 인해 실제 발생하는 문제 이슈](https://github.com/f-lab-edu/ootd-closet/issues/43)

테이블 풀 스캔으로 인해 실제 발생한 문제 이슈입니다. 대량 데이터 -> 조회 -> 풀스캔 -> DB CPU 사용률 상승 문제가 있습니다.

조회하는 패턴이 존재하기 때문에 해당 이슈는 테이블 칼럼에 인덱스를 추가해서 조회 성능을 개선하고자 합니다.

[UP](#summary)

### 단일 인덱스와 복합 인덱스

```sql
SELECT *
  FROM activityLog
 WHERE userId = 123
   AND activityDate = '2024-07-31'
ORDER BY activityDateTime DESC;
```

성능 문제가 없으려면 `userId`를 포함한 인덱스가 필요하다. 여기서 고민할 점은 `activityDate` 칼럼도 인덱스에 포함하느냐 하지 않느냐에 대한 것이다.

- 단일 인덱스 : `userId` 만 인덱스로 사용
- 복합 인덱스 : `(userId, activityDate)` 를 인덱스로 사용

이럴 경우에 사용자 당 가질 수 있는 activityDateTime 데이터가 얼마나 될지를 가늠해보면 단일 or 복합 인덱스 중 어느 인덱스를 사용해야 할지 판단하는 데 도움이 된다.

> [!NOTE]
> 개별 사용자 기준으로 1주일에 하루 정도 방문하고 평균 활동 데이터가 5건이면 1년을 활동해야 260건이 된다. 이렇게 5년을 꾸준히 활동해야 1,500 건이 쌓인다. 이정도 데이터 건수면 `userId` 칼럼만 사용하는 단일 인덱스를 사용해도 심각한 문제가 발생하지 않는다.

[UP](#summary)

### 선택도를 고려한 인덱스 칼럼 선택

인덱스를 생성할 때는 `선택도`가 높은 컬럼을 골라야한다.

`선택도`는 인덱스에서 특정 칼럼의 고유한 값의 비율을 나타냅니다. 선택도가 높으면 해당 칼럼에 **고유한 값이 많다는 뜻이며**, 선택도가 낮으면 고유한 값이 적다는 뜻입니다.

예를 들어 학생 20명 학급에서 성별(남자/여자)은 두 가지 뿐이다. 반면에 테이블의 PK 컬럼은 하나의 행이 생길 때마다 고유한 값이 생기기 때문에 선택도가 높다.

[UP](#summary)

### 커버링 인덱스 활용하기

커버링 인덱스는 특정 쿼리를 실행하는 데 필요한 모든 데이터를 인덱스 자체만으로 제공할 수 있는 인덱스입니다.

```sql
select activityDate, activityType
from activityLog
where activityDate = '2024-07-31' and activityType = 'VISIT';
```

인덱스를 통해서 실제 `clustered key` 를 참조해서 데이터에 접근해서 디스크 I/O가 발생합니다. 하지만, 커버링 인덱스는 실제 `clustered key` 의 디스크에 접근하지 않기 때문에 디스크 I/O가 발생하지 않습니다.

[UP](#summary)

### 인덱스는 필요한 만큼만 만들기

```sql
SELECT *
  FROM activityLog
 WHERE userId = 123 AND activityDate = '2025-08-29'
ORDER BY activityDateTime DESC;

SELECT *
  FROM activityLog
 WHERE userId = 123
   AND activityDate = '2025-08-29'
   AND activityType = 'BUY'
ORDER BY activityDateTime DESC;
```

자주 사용하는 이 두 쿼리를 빠르게 실행하기 위해 다음과 같이 2개의 복합 인덱스를 만들 수 있다.

- `(userId, activityDate)`
- `(userId, activityDate, activityType)`

여기서 두 번째 인덱스가 효과를 발휘하려면 한 사용자가 하루에 만들어 내는 데이터 개수가 조회 성능에 영향을 줄 만큼 많아야 한다.

> [!NOTE]
> 하루에 고작 수백 개의 데이터가 생긴다면 인덱스 추가 효과를 체감하기 어렵다.  
> 효과가 적은 인덱스를 추가하면 오히려 성능이 나빠질 수 있다. 인덱스는 조회 속도를 빠르게 해주지만 데이터 추가, 변경, 삭제 시에는 인덱스 관리에 따른 비용이 추가되기 때문이다.  
> 또한 **인덱스 자체가 데이터이기 때문에 인덱스가 많아질수록 메모리와 디스크 사용량도 함께 증가한다.**

새로 추가할 쿼리가 기존에 존재하는 인덱스를 사용하지 않을 때는 요구사항을 일부 변경할 수 있는지 검토해보자.

```sql
CREATE TABLE reservation (
  id bigint not null primary key,
  name varchar(30) not null,
  reserveDate date not null,
  state char(2) not null,
  regDt timestamp not null
);
create index idxRdate on reservation (reserveDate);
```

예약자 이름으로 조회하는 기능을 구현해야 할 경우, 다음처럼 name 칼럼을 비교할 수 있다.

```sql
SELECT *
  FROM reservation
 WHERE name = 'username'
ORDER BY regDt DESC;
```

`reservation` 테이블은 `name` 칼럼을 인덱스로 갖고 있지 않아 풀 스캔이 발생한다. 풀 스캔을 방지하기 위해 `name` 칼럼을 인덱스로 추가할 수도 있지만, 요구사항을 일부 변경하면 인덱스를 추가하지 않아도 된다.

- 특정 일자에 예약한 예약자 이름으로 조회

```sql
SELECT *
  FROM reservation
 WHERE reserveDate = '2024-09-09' AND name = 'username';
```

## 몇 가지 조회 성능 개선 방법

인덱스가 아니더라도 조회 성능을 개선할 방법이 존재한다.

### 미리 집계하기

`Feed` 테이블 데이터 조회  
FK 제약 조건을 이용해서 한 명이 하나의 피드에 좋아요를 누를 수 있는 요구사항이 존재한다.  
좋아요 숫자는 `FeedLike` 테이블에 적재되며, `member_id` 와 `feed_id` 를 이용해 중복되지 않고 저장합니다.

좋아요 개수를 조회하고, 개수를 기준으로 정렬하고자 한다.

```sql
select f.id, f.content,
  (select count(*) from feed_like fl where fl.feed_id = f.id) as like_cnt
from feed f
order by id, like_cnt  desc
limit 30;

or

select f.id, f.content, count(fl.feed_id) as like_cnt
from feed f
left join feed_like fl on f.id = fl.feed_id
group by f.id, f.content
order by f.id, like_cnt
limit 30;
```

두 쿼리 모두 기능을 수행하는데는 문제가 없지만 성능에 문제가 발생할 수 있다.

- 페이지네이션 하기 위해 limit과 count 함수를 이용했다.
- 한 쿼리에 30번의 추가 count 쿼리가 발생한다.
- 목록을 조회하는 쿼리 시간이 느려진다.

`목록 조회 쿼리 100ms + count 쿼리 100ms * 30 = 3100ms`  
3초의 시간이 걸리게 되며, 자주 조회되는 쿼리이며 사용자가 몰리 경우에는 조회 속도가 급격하게 느려지는 문제가 발생한다.

또는 `join` 과 `group by` 를 통해서 성능을 보다 올릴 수 있겠지만, 연산의 결과로 인해 성능 상 좋지 않다.

**해결 방법**  
`count`나 `sum`과 같은 집계 쿼리를 조회 시점에 실행하면서 발생하는 성능 문제를 해결하는 방법은 간단하다.

집계 데이터를 미리 계산해서 별도 칼럼에 저장하면 된다. `Feed` 테이블에 `like_cnt` 칼럼을 추가한다.  
좋아요 또는 취소 api가 호출되면 값을 업데이트 해준다.

```sql
select id, content, like_cnt
from feed
order by id desc
limit 30;
```

`Feed` 테이블에 `like_cnt` 칼럼을 추가하는 것은 데이터를 중복하게 비정규화 작업이다. `feed_like` 테이블로 개수를 구할 수 있기 때문이다. 또한 두 테이블의 값이 달라져 무결성이 깨지는 문제가 발생할 수도 있다.

하지만, 약간의 불일치를 감수하더라도 실시간 집계용 칼럼을 추가하는 것이 맞다고 생각한다. 목록을 보는 회원에게 좋아요 개수는 그렇게 중요한 문제가 아니다.

그리고 동시성 문제가 발생할 수 있다. 데이터베이스가 원자적 연산으로 처리하면 문제가 발생하지 않지만, 그렇지 않으면 값이 어떻게 변경될지 예측할 수 없다.

예를 들어 톰캣의 멀티 스레드 환경에서 여러 사용자가 동시에 좋아요를 누르거나 취소할 경우이다.
