Springboot repository layer에 존재하는 특정 엔티티 테스트 코드를 작성하며 공부를 진행하던 중 에러를 만나게 되었다.

조금 구체적으로 설명하면, `article` 엔티티 객체를 만들고 레포지터리리 테스트 코드를 작성하는데 에러가 발생했다.   
`TransientPropertyValueException` 

Article 객체 내부에 연관관계 매핑으로 `User` 를 단방향으로 지니고 있다. 테스트 코드를 작성할 때 처음에 userRepository에 대한 의존성이
존재하지 않았고, 그냥 User 객체를 만들어서 articleRepository에 저장해주면 되는 줄 알았다. 디비에서 찾을 수 없고 영속성 컨텍스트 내에서도
찾을 수 없는 데이터이기 때문에 필드 값이 null 이라는 에러를 뱉는 듯 싶다.


- 연관된 엔티티(User) 가 영속성 컨텍스트에 저장되지 않은 상태에서 참조되었을 때
- 즉, Article 엔티티를 저장하려 할 때 연관된 User 엔티티가 데이터베이스에 없거나, JPA 영속성 상태가 아닌 상태에서 참조됨


## 해결방법
1. 연관된 엔티티를 먼저 저장하기 
`User` 객체가 데이터베이스에 저장되어 있어야 `Article` 객체를 저장할 수 있다.

그런데, 이 방법으로 하려면 유저 레포지터리에 대한 의존성을 가지게 되어서 이렇게 테스트 하는것
에 대해서 거부감이 든다. 이게 맞는 방법인가?

2. 연관된 엔티티를 영속 상태로 유지하기 
테스트 코드에서 영속성 컨텍스트를 사용하는 방법
- @Transaction 어노테이션을 추가하여 테스트 메서드가 트랜잭션 안에서 실행되도록 설정한다.
```java
@Transactional
@Test
public void testSaveArticleWithTransaction() {
    User user = new User("testUser", "password");
    userRepository.save(user); // 영속 상태

    Article article = new Article("Test Title", "Test Content", user);
    articleRepository.save(article);

    // 검증
    assertNotNull(article.getId());
}
```
이는 이미 DataJpaTest 에 트랜잭션 어노테이션이 존재하기 때문에 이 방법이 해결방법이 아니라고 생각이 들었다.
결국에는 에러가 발생한 이유가 영속성 컨텍스트 내에 해당하는 User를 찾을 수 없기에 오류가 발생한다. 그렇다면, 테스트 코드 내에
UserRepository의 의존성 주입은 불가결한 요소였다는 것을 알 수 있었다. 나는 article 엔티티 객체를 테스트 하는데 User의 레포지터리가
의존하게 된다면, 테스트에 의존성이 생겨서 안안좋지 않을까 라는 생각이 들었었다. 의존성에 대한 경계가 테스트 코드를 작성하는데 
에러를 발생시켰지만, 의식적으로 이러한 생각을 하는것은 나쁘지 않다고 생각한다. 

이제 userRepository 의 의존성을 피하지는 못하니 어떻게 영속성 컨텍스트 내에 저장할까 고민이 되었다. 이에 두 가지 방법을 생각했다.
### 1. 테스트 코드 내에서 `User` 데이터 저장
테스트 코드에서 User 데이터를 직접 생성하고 저장하는 방식
- 간단하고 테스트 코드만으로 모든 데이터 흐름을 추적할 수 있다.
- 테스트 코드 내에서 데이터를 명시적으로 준비하므로 가독성이 높다.
- 테스트 독립성을 보장한다.

단점
- 테스트 코드가 길어질 수 있다.
- 중복 코드가 발생할 가능성이 있다.
### 2. SQL 파일로 초기 데이터 준비
테스트 실행 전에 SQL 스크립트를 사용하여 데이터를 준비하는 방법
- 여러 테스트에서 공통적으로 필요한 데이터가 있다면 재사용성이 높다.
- 테스트 데이터베이스를 미리 설정할 수 있어 더 복잡한 시나리오를 테스트하기 유리

단점
- SQL 스크립트와 코드간의 일관성 유지 ( 매우 번거러울 것 같다는 생각)
- 데이터 변경 시 SQL 파일을 업데이트해야 하므로 관리 비용이 늘어난다.
- 테스트마다 다른 데이터가 필요하면 설정이 번거러워질 수 있다.

이에 대한 결론은 하루동안 엔티티에 관해서 이것저것 공부를 진행하며, 엔티티 테스트를 진행을 하게 되었는데 느낀점이 있다.
어떤 방법이 좋을지는 내가 느끼기에 테스트 코드 내에서 저장하는 방식이 더 간편했다. SQL 스크립트
파일을 짜고, 데이터 컬럼들이 변경이 되면 관련 sql 스크립트도 맞게 수정해주어야 하는 품이 들어간다.
그래서 테스트 코드 내에서 객체를 생성하고 저장하는 방식으로 테스트하는 것이 조금 더 낫다고 생각이 들었다.
또한 매 테스트마다 객체를 생성하는 것이 아니라, 테스트 클래스 필드에 특정 객체를 선언해두고, `BeforeEach를` 통해서
객체를 초기화해주면 될것 같다.
