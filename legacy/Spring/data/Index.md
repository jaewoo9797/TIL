# 인덱스

# 목표

멘토링 시간에 인덱스에 대해서 조사해오라는 미션. 목표는 면접에서 자주 등장하는 질문에 대한 답변을 하기 위함.

### 인덱스 관련 영상

https://www.youtube.com/watch?v=iNvYsGKelYs - 처음에 이해하기 쉬운 설명

https://www.youtube.com/watch?v=IMDH4iAQ6zM

## 인덱스란 무엇인가?

인덱스를 구축하면 데이터베이스에서는 더 빠르고 쉽게 특정 레코드를 찾을 수 있습니다. 그러나 인덱스를 구축하면 데이터베이스의 부하가 증가하므로, 인덱스가 필요한 테이블에만 적절히 적용해야한다.

인덱스를 설정하면 더 빠르게 레코드를 찾을 수 있는 이유는 범위를 줄여가며 좁혀가기 때문이다. 인덱스를 이용해 데이터베이스가 풀 스캔을 통해 데이터를 찾는것에 성능이 향상된다.

![Image](https://github.com/user-attachments/assets/693d7f8e-0909-4ba2-8d5e-3f36e4efc7a2)

인덱스는 기본적으로 B-tree 구조를 가지고 있다. 이진 트리 형태로 되어있기 때문에 Binary-Tree를 의미한다. 이진 트리의 구조는 기본적으로 정렬이 되어있어야 한다. 테이블에 생성된 인덱스는 이처럼 데이터를 정렬하고 원하는 데이터를 빠르게 찾을 수 있어 검색 속도가 향상된다. 테이블에 생성된 인덱스는 B-tree 형태로 데이터가 추가적으로 필요하다. 

> 데이터베이스의 인덱스
> 

추가적인 저장 공간에 미리 정렬된 정보를 저장하여, 원하는 데이터를 찾기 위한 것

![Image](https://github.com/user-attachments/assets/088ea3c5-0df8-46e2-97a5-5275a6fab346)

## 인덱스의 장단점

인덱스를 사용하면 조회 성능이 향상될 수 있지만 데이터베이스 엔진이 새 행을 추가하거나 기존 행을 수정할 때 테이블 뿐만 아니라 ***인덱스도 함께 업데이트해야 하므로*** 삽입 및 업데이트 작업 속도가 느려질 수 있다.

추가적인 작업

- INSERT :  새로운 데이터에 대한 인덱스를 추가
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
- UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가

→ 데이터의 수정이 잦은 인덱스의 경우에 성능이 낮아진다. 또 데이터의 인덱스를 제거하는 것이 아니라 ‘사용하지 않음’으로 처리하고 남겨두기 때문에 수정 작업이 많은 경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점이 발생할 수 있다.

## 인덱스를 사용

인덱스를 효율적으로 사용하기 위해서는 데이터의 범위가 넓고 중복이 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋다.

→ 데이터의 범위가 어느 정도 많아지기 전에는 성능이 더 떨어질 수 있다.

- 테이블 크기가 작다면 풀 데이터 스캔이 더 빠를 수 있다.
- 데이터를 찾을 때 인덱스를 먼저 검색하고 다시 실제 데이터를 읽는 과정(I/O 오버헤드)

→ 데이터의 분포가 한정적일 경우에는 효과가 없다.

- 성별 같은 컬럼에 인덱스를 걸어도 의미가 없음. 골고루 분포되지 않고 특정 값을 검색할 때 인덱스를 사용해도 나머지 절반의 데이터를 읽어야 하기 때문임.

→ 작은 테이블에서 인덱스보다 메모리 캐싱이 더 유리함

- 작은 데이블은 데이터베이스 엔진이 내부적으로 메모리에 올려두고 바로 검색 가능
- 디스크 I/O 를 발생시키지 않고 빠르게 조회가 가능

| 테이블 크기 (행 수) | 인덱스 사용 여부 |
| --- | --- |
| 100~1,000 건 이하 | 풀 테이블 스캔이 더 빠를 가능성이 높음 |
| 1,000 ~ 10,000 건 | 조회 패턴에 따라 다름 |
| 10,000 ~ 100,000 건 | 인덱스 사용이 효과적 |
| 100,000 건 이상 | 인덱스가 없으면 조회 속도 저하 가능성이 높 |

어떤 인덱스가 효과적인지 확인하려면 EXPLAIN 명령어를 사용해서 쿼리 실행 계획을 확인하는게 좋다.

## 어떤 컬럼에 인덱스 설정?

고려 요소 

- 검색 쿼리가 자주 사용되는 컬럼 : 검색 쿼리가 자주 사용되는 컬럼에는 인덱스를 생성하는 것이 효율적이다.
- 테이블의 크기와 레코드의 개수 : 테이블의 크기와 레코드의 개수가 커질수록 인덱스 생성이 필요하다
- 컬럼의 데이터 유형 : 정수, 문자열 등과 같은 데이터 유형에 따라 인덱스 생성 방법이 달라진다.
- JOIN 쿼리 사용 여부 : JOIN 쿼리를 사용할 경우 관련 테이블의 컬럼에 인덱스를 설정하는 것이 효율적이다.

## 인덱스의 종류

### 1. 클러스터드 인덱스

클러스터형 인덱스는 ***테이블 전체가 정렬된 인덱스가 되는 방식의 인덱스 종류*** 이다. 

데이터와 함께 전체 테이블이 물리적으로 정렬된다. 클러스터형 인덱스는 출석부와 비슷하다. 출석부는 이름의 정렬 순서대로 정렬되어 있다.

클러스터형 인덱스는 **테이블 당 하나만 생성**할 수 있다. 특정 컬럼을 PK 로 지정하면 클러스터형 인덱스를 생성한다. 혹인 Unique + Not null 로 지정해도 클러스터형 인덱스를 생성한다. PK 컬럼과 Unique + Not null 컬럼이 동시에 존재하는 테이블은 PK를 우선으로 선택해 클러스터형 인덱스를 생성한다.

클러스터형 인덱스는 B+Tree 형태로 구성되어 있다. 

### 2. 비 클러스터형 인덱스 (Non-Clustered Index)

비 클러스터형 인덱스는 테이블에 있는 데이터의 실제 순서를 변경하지 않고 반영하지 않습니다. 

비클러스터형 인덱스는 보조 인덱스(Secondary Index)라고도 불리며, 물리적으로 테이블을 정렬하지 않는다. 그 대신 정렬된 별도의 인덱스 페이지를 생성하고 관리한다. 즉, 실제 데이터를 함께 가지고 있지 않다. 비클러스터형 인덱스는 책 뒷장의 ‘찾아보기’ 페이지와 닮아있다.

인덱스 페이지? (잘 이해가지 않음, 이후에 학습) 는 정렬되어 있지만, 실제 데이터 페이지는 정렬되지 않으므로 클러스터형 인덱스에 비해 삽입, 수정, 삭제 작업이 비교적 빠르다. 데이터 페이지에는 정렬 순서 상관없이 빈 곳에 데이터를 삽입하면 되기 때문이다.

### 참조

- https://kfintech.tistory.com/61
- https://hudi.blog/db-index-and-indexing-algorithms/
- https://rebro.kr/167
- https://hudi.blog/db-clustered-and-non-clustered-index/